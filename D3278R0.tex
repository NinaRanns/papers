% !TeX program = luatex
% !TEX encoding = UTF-8


\documentclass{wg21}

\usepackage{adjustbox}
\usepackage{enumitem}
\usepackage{epigraph}
\usepackage{fullpage}
\usepackage{listings}
\usepackage{minted}
\usepackage{multirow}
\usepackage{parskip}
\usepackage{soul}
\usepackage{ulem}
\usepackage{xcolor}
\usepackage{tcolorbox}
\usepackage{cprotect}

% For wording updates
\usepackage{changepage}

\frenchspacing

\tcbuselibrary{theorems}

\patchcmd{\thebibliography}{\section*{\refname}}{}{}{}

\setlength{\epigraphwidth}{0.9\textwidth}
\setlength{\epigraphrule}{0pt}

\definecolor{proposalBG}{RGB}{147,112,219}

\newcounter{proposalnum}
\newtcbtheorem[use counter=proposalnum]{proposal}
              {Proposal}
              {colback=proposalBG!20!white,colbacktitle={proposalBG!40!white},coltitle={black}}
              {prop}

\newtcbtheorem[auto counter,number within=proposalnum]{subproposal}
              {Proposal}
              {colback=proposalBG!20!white,colbacktitle={proposalBG!40!white},coltitle={black}}
              {subprop}

\title{Interaction between relocation and swap}
\docnumber{D3278R0}
\audience{EWG}
\author{Nina Ranns}{dinka.ranns@gmail.com}

\begin{document}
\maketitle

\begin{abstract}
\noindent
In this paper we analyse the relationship between relocation, assignmemt, and swap.
Additionally, we address the points raised in P3236 %(todo: insert link).
\end{abstract}

\tableofcontents

\clearpage
\section*{Revision History}

Revision 0

\section{Introduction}

\paper{P2786R5} and \paper{P1144R10} both attempt to address relocation and trivial relocation for the purposes of optimiziation. Both papers also define the meaning of relocation.

From P1144
"We define a new verb, "relocate," equivalent to a move and a destroy. For many C++ types, this is implementable "trivially," as a single memcpy."

From P2786
"â€” To relocate a type from memory address `src` to memory address `dst` means to perform an operation or series of operations such that an object equivalent (often identical) to that which existed at address `src`
exists at address `dst`, that the lifetime of the object at address `dst` has begun, and that the lifetime of the
object at address `src` has ended."

Many operations within the standard library are morally relocations, such as vector::erase and vector::insert, yet they are often implemented in terms of assignment. However, we argue assignment and relocation are two different notions.

Swap exchanges values of two existing objects, but can for a certain subset of types be implemented as a series of trivial relocations. It is important to note that swap, inherently, isn't a relocation. We do want to enable swap optimisations when we know that the trivial relocation will do "the right thing".

\section{Relocation and Trivial relocation}

We argue that all operations that morally perform relocation should be able to benefit from trivial relocation optimisations, according to the definition of trivially relocatable types in P2786 (Unlike P1144, P2786 does not take assignment operations into consideration when determining which type is implicitly trivially relocatable).

It is quite common to view operations like `vector::erase` and `vector::insert` as performing relocations. However, the standard specification is opaque about whether these operations are relocating whole objects or just managing values.

In practice, most standard library implementations use assignment when moving values to locations where there are currently objects.  In some cases, this is even implied with both requirements for assignability and statements like
\href{https://eel.is/c++draft/sequences#deque.modifiers-6}{the specification of deque}
"Complexity: The number of calls to the destructor of T is the same as the number of elements erased, but the number of calls to the assignment operator of T is no more than the lesser of the number of elements before the erased elements and the number of elements after the erased elements"

However, it is important to note that relocation exchanges objects and assignment exchanges values of objects. The distinction matters in cases where the identity of the object and its value are not the same thing. We can imagine an object that holds some trivially relocatable ID and a value. On assignment, the value is exchanged without affecting the ID. However, relocation should result in an object with the same ID. A type holding such an ID can reasonably not need a user defined copy constructor or destructor, but will need a user defined assignment operator in order to only assign the parts of the object that make up the value. (We talk about ID's, but we see similar semantics in \tcode{tuple<int\&>}). We argue that this category of types should not prevent library implementors from taking advantage of trivial relocation within the operations that are morally relocations : relocating operations that use assignment currently have an unclear semantic for these types, and it is questionable whether the new semantic would be wrong. We do not propose adding additional specifications to the library, we want to leave the choice on how and when these operations are optimised to the library authors.


While we want to allow existing implementations to optimise cases of relocations that are currenly implemented in terms of assignment, we do want to seperate the notions of assignment from the notion of relocation. Adding the notion of relocation to the standard is not just about managing existing cases of relocation, and we should not be limiting the meaning of relocation according to the implementations that were dones before the notion of relocation existed. We do not want to pessimise future implementations which are specified in terms of relocation because we have not distinguished between construction and assignment semantics so far.

Taking an approach where we reason about trivial relocation without taking assignment into consideration, while also having a way of distinguishing types for which assignment has different semantics to copy construction allows the implementors do have a choice of preserve the behaviour of existing methods for the types outlined above in the same way they might do for swap.

\section{swap}

When talking about swap, the standard talks about swapping *values*. For certain subset of types, a value is also the object representation. If value and object representation are the same, a swap can also be implemented as a set of relocation operations. Note that this is almost the opposite to the former case
- in `vector::insert` we can in some cases implement a relocation using assignment
- in swap, we can in some cases implement assignment using relocation


Two things need to hold for swap to be able to be reduced to relocation
1) the type needs to be relocatable
2) the semantic should not change if we use relocation instead of assignment

P1144 recognises the benefits of optimising swap to use relocation where possible. P3236 provides a request from library authors to be able to reason about when swap can be implemented in terms of relocation.

We argue that the way forward is to carve out types for which construction+destruction is equivalent to assignment. We refer to these types within this paper as replaceable types. A trait is_replaceable<T> could be provided. One possible specification of such a trait is one which is true for types where no copy constructor, assignment operator, or destructor is virtual or user provided, and false otherwise. A type could also specialise the trait to explicitly say whether the equivalence holds. Note that this paper is not proposing the exact semantics of such trait, we are simply demonstrating what such trait might look like.

Implementing swap would then be a case of writing a specialisation for types for which both is_trivially_relocatable and is_replaceable holds. Note that is_replaceable could also be used in other situations where one needs to understand whether assignment has different semantics to copy construction, like deciding when to optimise relocation operations that are currently implemented using assignment.

This solves the problem of \tcode{tuple<int>} vs \tcode{tuple<int\&>} problem raised by P3236.

An additional problem with implementing swap in terms of relocation is the fact that trivial relocation is usually implemented in a way that ends and starts lifetimes of objects that have been swapped. This has consequences in possibly adding UB where UB doesn't exist when swap is implemented in terms of assignment. In order to solve that problem, we would need a magic function that swaps the objects using relocation, but does not end lifetime of either of the objects.

Both a version of the above trait and the magic function are proposed in (%todo:insert number)


\section{virality of relocate}

When allowing user to mark their type as relocatable, there are several options

1) check whether all the subobjects of such type are relocatable, and prevent marking the top level type as relocatable if some parts are not relocatable
2) allow the author to mark the top level as relocatable only if all of the subobjects are not explicitly marked as not relocatable
3) allow the author to mark the top level as relocatable in all cases

We recognise that 2 and 3 allow for an easier transition. However, option 1 is the safest option. We can consider relaxing the rules at a later point to allow for more cases when a type can be marked as relocatable, but we can not make the rules more strict.

Note that the question of when to allow a type to be marked as relocatable based on the relocatibility of its subobjects is a separate question to whether relocation takes assignment into account.

\section{Attribute vs new syntax}

\paper{P3236R0} argues that a an attribute would allow enabling the feature in earlier language modes.
However, EWG reaffirmed many times that attribute should be ignorable and as such not have semantics impact.
This is part of the \href{https://eel.is/c++draft/dcl.attr#grammar-note-5}{C++ specification}.
Trivial relocation is both a contractual property of a type, and something that can be observed through traits.
For example, trivial relocatable types can be moved accross address spaces, in the context of GPU/heterogenous programming
(which doesn't imply their subobject are safe to use), which is a property the compiler \emph{must} preserve and enforce.

\tcode{no_unique_address} and the subsequent decision by some implementations not to adopt it caused significant pains
in the ecosystem, and we should try not to repeat the same mistakes.
Some implementers (notably Clang's) expressed their opposition to an attribute syntax for trivial relocation.
Following both EWG's and Implementers guidance, \paper{P2786R5} choose not to bring the question of attribute ignorability again,
preferring introducing a new contextual keyword.

We should note however that implementers can (and likely will) backport this feature in older language modes
(in part so that standard libraries can support relocation unconditionally).

Note that all implementations warn on unknown attributes such that using an attribute would not permit using
trivial relocation with older toolchain without the use of a macro.

%Finally, the question of whether we should have an attribute or a core language feature to mark a type as relocatable is a separate question to whether we should take assignment into account for relocation, and a separate question to whether we should allow marking a type relocatable if any of its subobjects are not relocatable.

\section{conclusion}

Separating relocation from assignment and having a trait that specifies whether assignment can be replaced with relocation offers the most benefit

- new relocation operations are not limited by the assignment operator of the type
- library implementors have a choice on choosing which way to optimise for already existing relocation operations, allowing them not to pessimise based on assignment operator
- swap can be correctly implemented

It is tempting to solve both relocation operations and swap in one go. However, we propose that it's better not to pessimise all current and future relocation operations because of swap, and to continue the efforts in allowing swap to be optimised too by pursuing the direction of defining what a replacable type is and making sure we do not introduce additional UB.

We should also come to an explicit agreement on attribute vs core feature aspect of relocation, and whether we should allow a type to be marked relocatable if its subobjects are not relocatable. While aspects of P2786 were discussed in EWG session in Tokyo 2024, no explicit polls were taken.

\appendix

\bibliographystyle{plain}
\bibliography{wg21}


\renewcommand{\section}[2]{}%

\begin{thebibliography}{9}

\end{thebibliography}
\end{document}


